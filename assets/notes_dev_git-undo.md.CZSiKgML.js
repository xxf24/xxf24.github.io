import{_ as s,a,aa as t,o as e}from"./chunks/framework.D5y5L8WJ.js";const c=JSON.parse('{"title":"Git 撤销操作","description":"","frontmatter":{"lastUpdateTime":"2024-11-28T01:13:48.000Z","date":"2023/4/6","title":"Git 撤销操作","category":"开发","tags":["git"]},"headers":[],"relativePath":"notes/dev/git-undo.md","filePath":"notes/dev/git-undo.md"}'),l={name:"notes/dev/git-undo.md"};function n(h,i,d,p,k,r){return e(),a("div",null,i[0]||(i[0]=[t(`<p>在我刚接触 git 时，看到过这么一种说法：git 很强，只要文件被追踪，就不用担心出现丢失问题。</p><p>日常使用中，我确实感受到 git 功能的强大，但时不时也会面临一些困境。究其原因，一方面是相关的命令太多，操作起来有一定的心智负担；另一方面还是担心会把历史提交或者已有改动给弄没了。</p><p>本文尝试归纳一些常见的撤销命令，以作备忘。</p><h2 id="reset-和-revert" tabindex="-1">reset 和 revert <a class="header-anchor" href="#reset-和-revert" aria-label="Permalink to &quot;reset 和 revert&quot;">​</a></h2><h3 id="辨析-git-reset-的选项" tabindex="-1">辨析 git reset 的选项 <a class="header-anchor" href="#辨析-git-reset-的选项" aria-label="Permalink to &quot;辨析 git reset 的选项&quot;">​</a></h3><p>git reset 用于将 HEAD 指针重置到指定的提交，根据传入选项的不同，会有不同的结果。常见有以下三种选项：</p><ul><li><code>--mixed</code> （默认选项）</li><li><code>--soft</code></li><li><code>--hard</code></li></ul><p>关于它们的区别，这里我动手实践了下：用以下 4 个文件来模拟 git 工作目录下文件可能的状态，然后执行 <code>git reset HEAD</code>，分别记录传入不同选项时的执行结果。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  new.md</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 新添加到暂存区的文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  package.json</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 有修改并且暂存的文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> readme.md</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # 有修改但未暂存的文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> untracked.md  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 新添加的还没有被追踪的文件</span></span></code></pre></div><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-2zhA7" id="tab-3wIm563" checked><label data-title="--mixed" for="tab-3wIm563">--mixed</label><input type="radio" name="group-2zhA7" id="tab-sch65ZG"><label data-title="--soft" for="tab-sch65ZG">--soft</label><input type="radio" name="group-2zhA7" id="tab-k334K0x"><label data-title="--hard" for="tab-k334K0x">--hard</label></div><div class="blocks"><div class="language-bash vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Unstaged</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> changes</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> after</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">       package.json</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">       readme.md</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package.json</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> readme.md</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> new.md</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> untracked.md</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --soft</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  new.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  package.json</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> readme.md</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> untracked.md</span></span></code></pre></div><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> reset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --hard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HEAD</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> now</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> untracked.md</span></span></code></pre></div></div></div><p>将结果汇总如下：</p><table tabindex="0"><thead><tr><th>文件名</th><th>操作前状态</th><th><code>--mixed</code></th><th><code>--soft</code></th><th><code>--hard</code></th></tr></thead><tbody><tr><td>package.json</td><td>修改后已暂存</td><td>🧹 修改后未暂存</td><td>无变化</td><td>✂️ 修改会被删</td></tr><tr><td>readme.md</td><td>修改后未暂存</td><td>无变化</td><td>无变化</td><td>✂️ 修改会被删</td></tr><tr><td>new.md</td><td>新添加已暂存</td><td>🧹 新添加未暂存</td><td>无变化</td><td>❌️ 文件会被删</td></tr><tr><td>untracked.md</td><td>新添加未暂存</td><td>无变化</td><td>无变化</td><td>无变化</td></tr></tbody></table><p>简而言之：</p><ul><li>从影响范围看，这三者都只影响已经被 git 追踪的文件</li><li>从操作风险看，只有 <code>--hard</code> 选项会导致改动或者文件被删</li><li>相比 <code>--soft</code> 选项， 默认选项 <code>--mixed</code> 会清空暂存区</li></ul><p>另外，还有两种不太常见的选项：</p><ul><li><code>--keep</code></li><li><code>--merge</code></li></ul><h3 id="关于-git-revert" tabindex="-1">关于 git revert <a class="header-anchor" href="#关于-git-revert" aria-label="Permalink to &quot;关于 git revert&quot;">​</a></h3><p>区别于 reset 命令，使用 revert 不会影响已有的提交记录，而是在反转指定的提交后，再创建一个新的提交记录，像是在提交记录上打了一个新的补丁，可能不好看但是稳定方便。</p><p>默认情况下使用 revert 后会自动创建一个新的提交来反转指定的更改。我们可以添加 <code>-no-commit</code> 选项（或者缩写形式 <code>-n</code>）来禁止这种行为。</p><p>另外，使用 revert 后若自动提交失败则表示有文件冲突，需要我们手动合并。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 撤销最近的提交</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HEAD</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 根据提交记录sha值撤销指定的提交</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit-id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 按范围撤销</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 比如撤销master分支上倒数第五次到倒数第二次（包含）之间的所有提交</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 也可以用对应sha值代替master~5，注意不要写错起始顺序</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> revert</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> master~5..master~2</span></span></code></pre></div><h3 id="撤销刚刚的-撤销" tabindex="-1">撤销刚刚的“撤销” <a class="header-anchor" href="#撤销刚刚的-撤销" aria-label="Permalink to &quot;撤销刚刚的“撤销”&quot;">​</a></h3><p>如果在执行 <code>git reset</code> 后需要撤销，可以考虑命令 <code>git reset &lt;commit-id&gt;</code>，其中，<code>commit-id</code> 可以通过 <code>git reflog</code> 来查找（但 git 仅保留本地 90 天内的提交记录）。</p><p>而执行 <code>git revert</code> 后的撤销就相对简单一些，再执行一次 <code>git revert</code> 即可。</p><h2 id="clean-和-rm" tabindex="-1">clean 和 rm <a class="header-anchor" href="#clean-和-rm" aria-label="Permalink to &quot;clean 和 rm&quot;">​</a></h2><p>二者都可以用来删除工作目录下的文件，区别在于它们的操作对象不同。</p><p><code>git clean</code> 仅针对未被 git 追踪的文件，而 <code>git rm</code> 则针对已被 git 追踪的文件。</p><p>相关命令：</p><ul><li><code>git clean -n</code>： 展示给用户看哪些文件会被删除，并不会真的执行</li><li><code>git clean -f</code>： 请谨慎使用任何一个 <code>-f</code> 选项 避免误删</li><li><code>git clean -df</code>： <code>-d</code> 表示目录 删除未被追踪的空目录</li><li><code>git clean -dfx</code>：删除所有没有被跟踪的文件和目录 包括那些被忽略的文件</li></ul><hr><ul><li><code>git rm &lt;filepath&gt;</code>： 将文件从工作目录中删除，仅当文件没有更改时有效</li><li><code>git rm -f &lt;filepath&gt;</code>： 强制将文件从工作区和暂存区中删除，即使文件有未提交的修改</li><li><code>git rm --cached &lt;filepath&gt;</code>： 将文件从暂存区中删除，但保留在工作目录中</li><li><code>git rm -r &lt;dir-path&gt;</code>： 递归地将目录及其子目录下的所有文件从工作目录和暂存区中删除</li></ul><h2 id="checkout-和-restore" tabindex="-1">checkout 和 restore <a class="header-anchor" href="#checkout-和-restore" aria-label="Permalink to &quot;checkout 和 restore&quot;">​</a></h2><p>使用 <code>git checkout &lt;filepath&gt;</code> 可以将工作目录下已经改动的指定文件恢复成上次提交的状态，这意味着它会丢失其中未暂存的更改，有一定风险。</p><p>另外考虑到 checkout 命令还有操作分支的用法，Git 在 2.23 版本中（2019 年 8 月发布）引入了新的 <code>git restore</code> 命令用于文件恢复操作。</p><p>相关命令：</p><ul><li><code>git restore &lt;filepath&gt; --staged</code>：将文件从暂存区域移出</li><li><code>git restore &lt;filepath&gt;</code>：将文件恢复到上次提交时的状态，同 git checkout</li><li><code>git restore .</code>：还原工作目录下所有未暂存的文件</li><li><code>git restore &#39;*.js</code>：还原所有扩展名为 .js 的文件的内容</li><li><code>git restore --source=&lt;commit&gt; &lt;filepath&gt;</code>：还原文件到指定的某次提交</li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><h3 id="撤销-git-add-的备选方案" tabindex="-1">撤销 git add 的备选方案 <a class="header-anchor" href="#撤销-git-add-的备选方案" aria-label="Permalink to &quot;撤销 git add 的备选方案&quot;">​</a></h3><ul><li><code>git restore --staged &lt;filepath&gt;</code>： 将暂存区指定文件恢复到工作目录</li><li><code>git restore --staged .</code>： 将暂存区所有文件恢复到工作目录</li><li><code>git reset &lt;filepath&gt;</code>： 将暂存区指定文件移除</li><li><code>git reset .</code>： 将暂存区所有文件移除</li><li><code>git rm --cached &lt;filepath&gt;</code>： 将暂存区指定文件移除</li></ul><h3 id="撤销-git-commit-的备选方案" tabindex="-1">撤销 git commit 的备选方案 <a class="header-anchor" href="#撤销-git-commit-的备选方案" aria-label="Permalink to &quot;撤销 git commit 的备选方案&quot;">​</a></h3><ul><li><code>git revert &lt;commit-id&gt;</code>： 创建一个新的提交，用于撤销指定提交的修改</li><li><code>git reset --soft &lt;commit-id&gt;</code>： 将当前分支重置到指定提交，并将修改放到暂存区</li><li><code>git reset &lt;commit-id&gt;</code>： 将当前分支重置到指定提交，并将修改放到工作目录</li><li><code>git reset --hard &lt;commit-id&gt;</code>： 将当前分支重置到指定提交，并丢弃所有修改</li></ul><h3 id="撤销-git-push-的备选方案" tabindex="-1">撤销 git push 的备选方案 <a class="header-anchor" href="#撤销-git-push-的备选方案" aria-label="Permalink to &quot;撤销 git push 的备选方案&quot;">​</a></h3><ul><li><code>git revert &lt;commit-id&gt;</code>： 创建一个新的提交，用于撤销指定的提交，并将其推送到远程分支</li><li><code>git reset --hard &lt;commit-id&gt;</code>： 将当前分支重置到指定提交，并丢弃所有修改，然后强制推送，但这会影响远程分支的提交记录历史，不建议在有多人协作的仓库上使用</li><li><code>git rebase -i &lt;commit-id&gt;</code>： 将当前分支的提交记录重新排序、编辑或删除，然后强制推送，这会改变提交记录的顺序，还是不建议在多人协作的仓库上使用</li></ul><h2 id="情景模拟" tabindex="-1">情景模拟 <a class="header-anchor" href="#情景模拟" aria-label="Permalink to &quot;情景模拟&quot;">​</a></h2><h3 id="情景一" tabindex="-1">情景一 <a class="header-anchor" href="#情景一" aria-label="Permalink to &quot;情景一&quot;">​</a></h3><blockquote><p>假设我修改一些了文件并且添加到暂存区，但没有执行提交，后续误操作将这些文件从硬盘上删除了，那么我的修改还能找回吗？</p></blockquote><p>可以使用 <code>git fsck --lost-found</code> 命令，这会显示将所有未引用的对象（包括暂存的文件），比如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dangling</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> blob</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> adb42b2f0dd6c5bb52be6049bd63fb3e14eef86f</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dangling</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> blob</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 7e491fa4f8a4f4879b87a29e911ed2b50f7b83a8</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dangling</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> blob</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a906cb2a4a904a152e80877d4088654daad0c859</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span></code></pre></div><p>运行 <code>git show &lt;blob hash&gt;</code> 命令，可以查看对应 blob hash 对象的内容，如果确认是要恢复的文件，可以执行 <code>git cat-file -p adb42b2f0dd6c5bb52be6049bd63fb3e14eef86f &gt; &lt;filepath&gt;</code> 将内容写入到指定的路径中，或者直接浏览工作目录下的 .git/lost-found 目录，上述所有内容都会被写入到该目录下。</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p></p><p>本地改动后及时提交，不用担心会有冗长的提交记录，在推送前稍微 &quot;打平&quot; 即可</p></div><h3 id="情景二" tabindex="-1">情景二 <a class="header-anchor" href="#情景二" aria-label="Permalink to &quot;情景二&quot;">​</a></h3><blockquote><p>假设我误将一些敏感文件提交到了远程仓库，该如何撤回，且最好在远程分支上不留痕迹？</p></blockquote><p>撤回可参考小结中 git push 的备选方案。但想要不留痕迹，意味着需要修改提交历史，得使用强制推送。这其实相当麻烦，特别时有其他人也在推送，或者自己没有强推的权限，这些都需要额外的沟通成本。</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>在向公共仓库 push 代码前，相比于为可能出现的错误的提交买单，多检查一下要提交的文件总是值得的。</p></div><h2 id="后记" tabindex="-1">后记 <a class="header-anchor" href="#后记" aria-label="Permalink to &quot;后记&quot;">​</a></h2><p>我发现在日常使用中，遇到问题时向 <code>ChatGPT</code> 或者 <code>new bing</code> 求助，也能获得一些不错的解决方案，尤其是当自己毫无头绪的时候 🤔。</p>`,56)]))}const g=s(l,[["render",n]]);export{c as __pageData,g as default};
