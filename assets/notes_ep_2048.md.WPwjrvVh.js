const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/chunks/index.NCqY71vi.js","assets/chunks/framework.D5y5L8WJ.js","assets/chunks/utils.DUgioOpr.js"])))=>i.map(i=>d[i]);
import{_ as r,a as l,b as t,e as o,R as i,aa as d,f as n,o as c,ab as s}from"./chunks/framework.D5y5L8WJ.js";const f=JSON.parse('{"title":"2048","description":"","frontmatter":{"lastUpdateTime":"2024-11-26T01:09:41.000Z","date":"2023/3/17","title":"2048","category":"练习","tags":["小游戏"]},"headers":[],"relativePath":"notes/ep/2048.md","filePath":"notes/ep/2048.md"}'),h={name:"notes/ep/2048.md"};function p(_,e,u,b,g,x){const a=n("DemoWrapper");return c(),l("div",null,[e[0]||(e[0]=t("p",null,'多年前，我在初学编程时曾用 cocos 引擎仿做过（🐶 "cv" 大法） "2048" 小游戏，不过由于没有备份，那时候写的代码都找不到了。最近我用 vue 重新实现了一份，以作怀念。',-1)),e[1]||(e[1]=t("h2",{id:"试玩",tabindex:"-1"},[o("试玩 "),t("a",{class:"header-anchor",href:"#试玩","aria-label":'Permalink to "试玩"'},"​")],-1)),i(a,{loader:()=>s(()=>import("./chunks/index.NCqY71vi.js"),__vite__mapDeps([0,1,2]))}),e[2]||(e[2]=d('<h2 id="日志" tabindex="-1">日志 <a class="header-anchor" href="#日志" aria-label="Permalink to &quot;日志&quot;">​</a></h2><h3 id="方块移动逻辑" tabindex="-1">方块移动逻辑 <a class="header-anchor" href="#方块移动逻辑" aria-label="Permalink to &quot;方块移动逻辑&quot;">​</a></h3><p>&quot;2048&quot; 的玩法很简单，第一次玩的话不需要看游戏说明也可以快速上手。不过在实现的过程中我也遇到了不少问题，我觉得最关键的部分在于如何实现方块的移动逻辑。</p><p>在试玩 <a href="https://github.com/gabrielecirulli/2048" target="_blank" rel="noreferrer">gabrielecirulli 开源的版本</a> 后，我记录了如下几组典型数据：</p><blockquote><p>说明</p><ul><li>每一行（列）方格数字均用一个四元组表示（其中，符号 <code>_</code> 表示空位）</li><li>每次移动均为向右 👉 移动</li></ul></blockquote><table tabindex="0"><thead><tr><th style="text-align:center;">序号</th><th style="text-align:center;">移动前</th><th style="text-align:center;">移动后</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;"><code>2 _ 2 _</code></td><td style="text-align:center;"><code>_ _ _ 4</code></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;"><code>2 2 4 4</code></td><td style="text-align:center;"><code>_ _ 4 8</code></td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;"><code>2 2 4 8</code></td><td style="text-align:center;"><code>_ 4 4 8</code></td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;"><code>2 2 2 _</code></td><td style="text-align:center;"><code>_ _ 2 4</code></td></tr></tbody></table><ul><li>前 2 组很容易理解，相邻（中间允许有空位）的两个数字如果相等就合并，然后尽可能往右填满空位</li><li>从第 3 组的结果不是 <code>_ _ 8 8</code> ，推测已经合并过的格子，不能继续参与本轮后续合并了</li><li>从第 4 组的结果不是 <code>_ _ 4 2</code> ，推测合并的优先顺序是从靠近底部的格子开始（可以把移动方向视为重力方向，底部的格子优先碰撞合并）</li></ul><p>到这里问题就转变成实现一个转换函数：输入移动前的四元组和移动方向，输出移动后的四元组。<br> 另外考虑到四个方向移动的对称性，我们只需要实现一个方向的逻辑，就可以依葫芦画瓢推广到其它三个方向上。</p><h3 id="ai" tabindex="-1">AI <a class="header-anchor" href="#ai" aria-label="Permalink to &quot;AI&quot;">​</a></h3><p>🤔 如何实现让电脑自己玩，且能有可能合成出 2048 呢 ？挖坑待填...</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/2048_(video_game)" target="_blank" rel="noreferrer">2048 | 维基百科</a></li><li><a href="https://github.com/gabrielecirulli/2048" target="_blank" rel="noreferrer">gabrielecirulli-2048 | github</a>： 文中提到的试玩版本，可能是最早的 &quot;2048&quot; Web 版本</li></ul>',12))])}const y=r(h,[["render",p]]);export{f as __pageData,y as default};
