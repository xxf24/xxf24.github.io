const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/chunks/index.BuIIRDsi.js","assets/chunks/framework.D5y5L8WJ.js","assets/chunks/utils.DUgioOpr.js"])))=>i.map(i=>d[i]);
import{_ as o,a as l,b as t,e as a,R as i,aa as n,f as d,o as p,ab as s}from"./chunks/framework.D5y5L8WJ.js";const q=JSON.parse('{"title":"扫雷","description":"","frontmatter":{"lastUpdateTime":"2024-11-28T01:25:55.000Z","date":"2023/3/1","title":"扫雷","category":"练习","tags":["小游戏"]},"headers":[],"relativePath":"notes/ep/minesweeper.md","filePath":"notes/ep/minesweeper.md"}'),h={name:"notes/ep/minesweeper.md"};function b(m,e,c,u,f,_){const r=d("DemoWrapper");return p(),l("div",null,[e[0]||(e[0]=t("p",null,[a("某天我在浏览 B 站时看到了 "),t("a",{href:"https://antfu.me/",target:"_blank",rel:"noreferrer"},"antfu"),a(" 用 vue 写扫雷的 "),t("a",{href:"https://www.bilibili.com/video/BV1ia411b7jY/",target:"_blank",rel:"noreferrer"},"直播录像"),a("，觉得很有意思，当时就想着自己也做一个试试。于是乎经过一段漫长的实践，可算是做了出来 😀。")],-1)),e[1]||(e[1]=t("h2",{id:"试玩体验",tabindex:"-1"},[a("试玩体验 "),t("a",{class:"header-anchor",href:"#试玩体验","aria-label":'Permalink to "试玩体验"'},"​")],-1)),i(r,{loader:()=>s(()=>import("./chunks/index.BuIIRDsi.js"),__vite__mapDeps([0,1,2]))}),e[2]||(e[2]=n('<small><p>选项说明：</p><ul><li><code>✅ 🚩</code>：勾选后，点击未翻开的格子时，模拟右击操作（即切换 插旗/取消插旗）</li><li><code>✅ 🚀</code>：勾选后，点击已翻开的格子时，追加双击操作</li></ul></small><h2 id="日志" tabindex="-1">日志 <a class="header-anchor" href="#日志" aria-label="Permalink to &quot;日志&quot;">​</a></h2><h3 id="操作说明" tabindex="-1">操作说明 <a class="header-anchor" href="#操作说明" aria-label="Permalink to &quot;操作说明&quot;">​</a></h3><p>扫雷的胜利条件是翻开棋盘上所有非雷的格子，如果翻到有雷的格子则游戏失败。游戏过程中若玩家断定某个未翻开的格子是雷时，可以通过插旗进行标记，如果刚好把都所有未翻开的雷全部插上旗，也可以算游戏胜利。</p><p>游戏包含了以下三种基础的鼠标操作：</p><table tabindex="0"><thead><tr><th>鼠标</th><th>未翻开的格子</th><th>已翻开的格子</th></tr></thead><tbody><tr><td>单击</td><td>有插旗就取消插旗，否则翻开</td><td>高亮周围（共 8 个格子）还未翻开的格子</td></tr><tr><td>右击</td><td>在 插旗/取消插旗 之间切换</td><td>同上</td></tr><tr><td>双击</td><td>高亮格子自身</td><td>如果有数字且该数字刚好等于周围插旗的数量，那么会翻开周围所有未插旗的格子</td></tr></tbody></table><blockquote><p>ps：话说双击这个操作我刚开始还以为是同时点击鼠标左右键... 😓</p></blockquote><h3 id="开局布雷算法" tabindex="-1">开局布雷算法 <a class="header-anchor" href="#开局布雷算法" aria-label="Permalink to &quot;开局布雷算法&quot;">​</a></h3><p>如何将 N 个雷均匀放置在 W × H 的地图上？ 这是我遇到的第一个算法难点。</p><p>我们当然很容易想到：将地图块预先编号，然后进行不放回抽样，连续进行 N 次后，得到的所有编号就是应该布雷的区域。这种做法使得我们可以保证雷是随机分布在各个小块中的。但它的游戏体验好吗？</p><p>嗯，玩家可能会在翻开第一块后就 GG 了，这样的话游戏就太不友好了。很容易想到，我们可以等玩家翻开第一块后，再执行随机布雷的算法，从而避免出现开局就炸的极端情况。这也是我目前的做法。</p><p>但多玩几次后，我发现这种做法还是有点问题的，特别是当游戏难度变高后（此时地图上地雷密度变大），很容易开局后连续翻开几块都没有触发“自动展开逻辑”，这让玩家接着翻下一块时充满了不确定性。</p><p>所以个人觉得好点的布雷算法，应该是在确保给到玩家一个良好的“局面”后（这个局面应该保证玩家至少可以确认一个一定不是雷的区域），再让玩家有几率翻到雷。不过很遗憾，我并没有在游戏中实现这一步。</p><h3 id="自动展开逻辑" tabindex="-1">自动展开逻辑 <a class="header-anchor" href="#自动展开逻辑" aria-label="Permalink to &quot;自动展开逻辑&quot;">​</a></h3><p>这个可以看作是游戏中的额外奖赏机制：当你翻开一块雷，且周围区域都不是雷时，就会触发该奖赏：自动翻开周围所有小格，从而帮玩家节省操作时间。</p><p>由于当系统自动翻开周围所有小格时，如果其中有小格也满足周围区域都不是雷，还会接着触发。故我们可以尝试用递归方式去处理。具体实践中需要注意递归终止条件，避免出现递归死循环。</p><ol><li>翻开小格时，及时标记上“已翻”标记</li><li>获取周围的小格时，排除掉这些有“已翻”标记的</li></ol><h2 id="后记" tabindex="-1">后记 <a class="header-anchor" href="#后记" aria-label="Permalink to &quot;后记&quot;">​</a></h2><p>其实从上面的操作说明中可以看到，扫雷的鼠标交互还是挺丰富的。微软当年（1992 年）将扫雷内置在 windows 3.1 系统中发布，也希望用户通过扫雷来熟悉鼠标操作。</p><p>如今公众日常使用最广泛的人机交互应该算是触屏方式，但移动端的触屏并不能很好模拟完整的鼠标操作（比如右击和双击）。相比之前的 2048，扫雷并不适合在触屏上玩，这也是我在复刻游戏时的感想。</p><p>游戏寓教于乐的方式可以帮助用户快速熟悉新的交互逻辑，比如本文中提到的扫雷（对应鼠标操作），2048（对应触屏滑动），以及当年 iPhone4 发布会上乔布斯曾用玩游戏的方式来演示过陀螺仪。那么今年（2023 年）苹果公司新发布的 Vision Pro，是否又能给大众带来一套全新的交互体验呢？</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)" target="_blank" rel="noreferrer">扫雷 | 维基百科</a></li><li><a href="https://youtu.be/ZOoXpoHpFHo" target="_blank" rel="noreferrer">踩地雷比你想的要深奥许多 @啾啾鞋 | youtube</a></li><li><a href="https://minesweeper.online/cn/" target="_blank" rel="noreferrer">minesweeper.online</a>：一个在线的扫雷游戏平台，也列出了扫雷的详细规则和玩法技巧</li></ul>',23))])}const w=o(h,[["render",b]]);export{q as __pageData,w as default};
